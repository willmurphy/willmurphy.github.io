<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chess</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    margin: 20px 0 10px;
    font-size: 2rem;
    letter-spacing: 2px;
    color: #f0d9b5;
  }
  .controls {
    display: flex;
    gap: 12px;
    margin-bottom: 12px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }
  .controls button, .controls select {
    padding: 8px 18px;
    border: none;
    border-radius: 6px;
    font-size: 0.95rem;
    cursor: pointer;
    background: #16213e;
    color: #e0e0e0;
    border: 1px solid #0f3460;
    transition: background 0.2s;
  }
  .controls button:hover, .controls select:hover {
    background: #0f3460;
  }
  .controls select { appearance: auto; }
  .game-container {
    display: flex;
    gap: 24px;
    align-items: flex-start;
    flex-wrap: wrap;
    justify-content: center;
    padding: 0 16px;
  }
  .board-section { display: flex; flex-direction: column; align-items: center; }
  .captured-row {
    display: flex;
    min-height: 36px;
    font-size: 1.5rem;
    gap: 2px;
    padding: 4px 0;
    flex-wrap: wrap;
    max-width: 480px;
    justify-content: center;
  }
  .board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    width: min(480px, 90vw);
    border: 3px solid #0f3460;
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    flex-shrink: 0;
  }
  .square {
    aspect-ratio: 1 / 1;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    position: relative;
    transition: background 0.1s;
    overflow: hidden;
  }
  .piece-svg {
    width: 80%;
    height: 80%;
    filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));
  }
  .board-section { position: relative; }
  .anim-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 50;
  }
  .animating-piece {
    position: absolute;
    pointer-events: none;
    will-change: transform;
  }
  .animating-piece .piece-svg {
    width: 80%;
    height: 80%;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
  }
  .move-arrow {
    position: absolute;
    pointer-events: none;
  }
  .square.light { background: #f0d9b5; }
  .square.dark { background: #b58863; }
  .square.selected { background: #7fc97f !important; }
  .square.legal-move::after {
    content: '';
    position: absolute;
    width: 28%;
    height: 28%;
    background: rgba(0,0,0,0.2);
    border-radius: 50%;
  }
  .square.last-move { background: rgba(255, 255, 100, 0.45) !important; }
  .square.legal-capture {
    background: radial-gradient(transparent 55%, rgba(0,0,0,0.3) 55%) !important;
  }
  .square.check { background: radial-gradient(ellipse at center, #ff0000 0%, #cc0000 30%, rgba(200,0,0,0.3) 80%, transparent 100%) !important; }
  .status {
    margin: 10px 0;
    font-size: 1.15rem;
    min-height: 1.4em;
    font-weight: 600;
    text-align: center;
  }
  .status.check-status { color: #ff6b6b; }
  .status.mate-status { color: #ffd700; }
  .sidebar {
    background: #16213e;
    border-radius: 8px;
    border: 1px solid #0f3460;
    padding: 16px;
    width: 220px;
    max-height: min(560px, 85vh);
    display: flex;
    flex-direction: column;
  }
  .sidebar h3 {
    margin-bottom: 8px;
    color: #f0d9b5;
    font-size: 1rem;
    text-align: center;
  }
  .move-list {
    flex: 1;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    line-height: 1.6;
  }
  .move-row { display: flex; gap: 8px; }
  .move-num { color: #888; min-width: 30px; text-align: right; }
  .move-white, .move-black { min-width: 65px; }
  .promotion-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }
  .promotion-dialog {
    background: #16213e;
    border-radius: 12px;
    border: 2px solid #0f3460;
    padding: 20px;
    text-align: center;
  }
  .promotion-dialog h3 { margin-bottom: 12px; color: #f0d9b5; }
  .promotion-pieces {
    display: flex;
    gap: 8px;
    justify-content: center;
  }
  .promotion-piece {
    font-size: 2.5rem;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    border-radius: 8px;
    background: #1a1a2e;
    border: 2px solid #0f3460;
    transition: all 0.15s;
  }
  .promotion-piece:hover {
    background: #0f3460;
    transform: scale(1.1);
  }
  .coord-label {
    position: absolute;
    font-size: 0.6rem;
    font-weight: 700;
    pointer-events: none;
  }
  .file-label { bottom: 1px; right: 3px; }
  .rank-label { top: 1px; left: 3px; }
  .square.light .coord-label { color: #b58863; }
  .square.dark .coord-label { color: #f0d9b5; }
  .speech-wrapper {
    display: flex;
    align-items: flex-end;
    gap: 8px;
    margin-bottom: 10px;
    max-width: min(480px, 90vw);
    width: 100%;
    transition: opacity 0.3s;
  }
  .speech-wrapper.empty { opacity: 0.4; }
  .ai-avatar {
    font-size: 1.8rem;
    flex-shrink: 0;
    line-height: 1;
    padding-bottom: 4px;
  }
  .speech-bubble {
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 12px;
    padding: 10px 16px;
    min-height: 44px;
    flex: 1;
    display: flex;
    align-items: center;
    position: relative;
    font-size: 0.95rem;
    line-height: 1.4;
    color: #e0e0e0;
  }
  .speech-bubble::after {
    content: '';
    position: absolute;
    bottom: 10px;
    left: -8px;
    width: 0; height: 0;
    border-top: 6px solid transparent;
    border-bottom: 6px solid transparent;
    border-right: 8px solid #16213e;
  }
  .speech-bubble::before {
    content: '';
    position: absolute;
    bottom: 9px;
    left: -10px;
    width: 0; height: 0;
    border-top: 7px solid transparent;
    border-bottom: 7px solid transparent;
    border-right: 10px solid #0f3460;
  }
  .speech-bubble .ai-text {
    flex: 1;
    min-height: 1.4em;
  }
  .hint-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 45;
  }
  @media (max-width: 720px) {
    .game-container { flex-direction: column; align-items: center; }
    .sidebar { width: min(480px, 90vw); max-height: 200px; }
  }
</style>
</head>
<body>

<h1>CHESS</h1>

<div class="controls">
  <button id="newGameBtn">New Game</button>
  <select id="modeSelect">
    <option value="ai">vs Computer</option>
    <option value="human">vs Human</option>
  </select>
  <select id="difficultySelect">
    <option value="2">Easy</option>
    <option value="3" selected>Medium</option>
    <option value="4">Hard</option>
  </select>
  <button id="hintBtn">Hint</button>
</div>

<div class="game-container">
  <div class="board-section">
    <div class="speech-wrapper empty" id="speechWrapper">
      <span class="ai-avatar">ðŸ¤–</span>
      <div class="speech-bubble" id="speechBubble">
        <span class="ai-text" id="aiText">Let's play! Make your move.</span>
      </div>
    </div>
    <div class="captured-row" id="capturedBlack"></div>
    <div class="board" id="board"></div>
    <div class="captured-row" id="capturedWhite"></div>
    <div class="status" id="status">White to move</div>
  </div>
  <div class="sidebar">
    <h3>Moves</h3>
    <div class="move-list" id="moveList"></div>
  </div>
</div>

<div class="promotion-overlay" id="promotionOverlay" style="display:none;">
  <div class="promotion-dialog">
    <h3>Promote pawn to:</h3>
    <div class="promotion-pieces" id="promotionPieces"></div>
  </div>
</div>

<script>
// SVG piece paths â€” consistent rendering on all platforms
const PIECE_PATHS = {
  K: 'M22.5 11.63V6M20 8h5M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5M12.5 37c5.5 3.5 14.5 3.5 20 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-2.5-7.5-12-10.5-16-4-3 6 6 10.5 6 10.5v7',
  Q: 'M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26zM9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4',
  R: 'M9 39h27v-3H9v3zM12.5 32l1.5-2.5h17l1.5 2.5h-20zM12 36v-4h21v4H12zM14 29.5v-13h17v13H14zM14 16.5L11 14h23l-3 2.5H14zM11 14V9h4v2h5V9h5v2h5V9h4v5H11z',
  B: 'M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.35.49-2.32.47-3-.5 1.35-1.46 3-2 3-2zM15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2zM25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z',
  N: 'M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.04-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3',
  P: 'M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03C15.41 27.09 11 31.58 11 39.5H34c0-7.92-4.41-12.41-7.41-13.47C28.06 24.84 29 23.03 29 21c0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z'
};

function makePieceSVG(type, color) {
  const fill = color === 'w' ? '#fff' : '#222';
  const stroke = color === 'w' ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.25)';
  const strokeW = color === 'w' ? 1.5 : 1.2;
  const path = PIECE_PATHS[type];
  let extra = '';
  // King cross: render as explicit stroke-only lines so it shows on both colors
  if (type === 'K') {
    const crossStroke = color === 'w' ? 'rgba(0,0,0,0.6)' : '#000';
    extra = `<line x1="22.5" y1="6" x2="22.5" y2="11.5" stroke="${crossStroke}" stroke-width="${strokeW + 0.5}" stroke-linecap="round"/>` +
            `<line x1="20" y1="8" x2="25" y2="8" stroke="${crossStroke}" stroke-width="${strokeW + 0.5}" stroke-linecap="round"/>`;
  }
  // Split into separate path elements, skip the cross segments for King (handled above)
  const segments = path.split('M').filter(Boolean);
  const paths = segments.map(d => {
    const full = 'M' + d;
    // Skip King cross line segments
    if (type === 'K' && (full === 'M22.5 11.63V6' || full === 'M20 8h5')) return '';
    return `<path d="${full}"/>`;
  }).join('');
  return `<svg class="piece-svg" viewBox="0 0 45 45" xmlns="http://www.w3.org/2000/svg"><g fill="${fill}" stroke="${stroke}" stroke-width="${strokeW}" stroke-linecap="round" stroke-linejoin="round">${paths}</g>${extra}</svg>`;
}

// Lookup for display (used by captured pieces row)
function pieceHTML(pieceChar) {
  const type = pieceChar.toUpperCase();
  const color = pieceChar === pieceChar.toUpperCase() ? 'w' : 'b';
  return makePieceSVG(type, color);
}

const PIECE_VALUES = { P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000 };

// Piece-square tables (from white's perspective, index 0 = a8)
const PST = {
  P: [
     0,  0,  0,  0,  0,  0,  0,  0,
    50, 50, 50, 50, 50, 50, 50, 50,
    10, 10, 20, 30, 30, 20, 10, 10,
     5,  5, 10, 25, 25, 10,  5,  5,
     0,  0,  0, 20, 20,  0,  0,  0,
     5, -5,-10,  0,  0,-10, -5,  5,
     5, 10, 10,-20,-20, 10, 10,  5,
     0,  0,  0,  0,  0,  0,  0,  0
  ],
  N: [
    -50,-40,-30,-30,-30,-30,-40,-50,
    -40,-20,  0,  0,  0,  0,-20,-40,
    -30,  0, 10, 15, 15, 10,  0,-30,
    -30,  5, 15, 20, 20, 15,  5,-30,
    -30,  0, 15, 20, 20, 15,  0,-30,
    -30,  5, 10, 15, 15, 10,  5,-30,
    -40,-20,  0,  5,  5,  0,-20,-40,
    -50,-40,-30,-30,-30,-30,-40,-50
  ],
  B: [
    -20,-10,-10,-10,-10,-10,-10,-20,
    -10,  0,  0,  0,  0,  0,  0,-10,
    -10,  0, 10, 10, 10, 10,  0,-10,
    -10,  5,  5, 10, 10,  5,  5,-10,
    -10,  0, 10, 10, 10, 10,  0,-10,
    -10, 10, 10, 10, 10, 10, 10,-10,
    -10,  5,  0,  0,  0,  0,  5,-10,
    -20,-10,-10,-10,-10,-10,-10,-20
  ],
  R: [
     0,  0,  0,  0,  0,  0,  0,  0,
     5, 10, 10, 10, 10, 10, 10,  5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
     0,  0,  0,  5,  5,  0,  0,  0
  ],
  Q: [
    -20,-10,-10, -5, -5,-10,-10,-20,
    -10,  0,  0,  0,  0,  0,  0,-10,
    -10,  0,  5,  5,  5,  5,  0,-10,
     -5,  0,  5,  5,  5,  5,  0, -5,
      0,  0,  5,  5,  5,  5,  0, -5,
    -10,  5,  5,  5,  5,  5,  0,-10,
    -10,  0,  5,  0,  0,  0,  0,-10,
    -20,-10,-10, -5, -5,-10,-10,-20
  ],
  K: [
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -20,-30,-30,-40,-40,-30,-30,-20,
    -10,-20,-20,-20,-20,-20,-20,-10,
     20, 20,  0,  0,  0,  0, 20, 20,
     20, 30, 10,  0,  0, 10, 30, 20
  ]
};

let game, selectedSquare, legalMovesCache, aiThinking = false, aiTimer = null;

function initGame() {
  game = {
    board: [],
    turn: 'w',
    castling: { K: true, Q: true, k: true, q: true },
    enPassant: null,
    moves: [],
    captured: { w: [], b: [] },
    halfMoves: 0,
    gameOver: false
  };
  selectedSquare = null;
  legalMovesCache = [];
  // Setup board: row 0 = rank 8, row 7 = rank 1
  const back = ['r','n','b','q','k','b','n','r'];
  for (let r = 0; r < 8; r++) {
    game.board[r] = [];
    for (let c = 0; c < 8; c++) {
      if (r === 0) game.board[r][c] = back[c];        // black back rank
      else if (r === 1) game.board[r][c] = 'p';       // black pawns
      else if (r === 6) game.board[r][c] = 'P';       // white pawns
      else if (r === 7) game.board[r][c] = back[c].toUpperCase(); // white back rank
      else game.board[r][c] = null;
    }
  }
}

function isWhite(p) { return p && p === p.toUpperCase(); }
function isBlack(p) { return p && p === p.toLowerCase(); }
function colorOf(p) { return p ? (isWhite(p) ? 'w' : 'b') : null; }
function typeOf(p) { return p ? p.toUpperCase() : null; }
function inBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

function cloneGame(g) {
  return {
    board: g.board.map(row => [...row]),
    turn: g.turn,
    castling: { ...g.castling },
    enPassant: g.enPassant ? [...g.enPassant] : null,
    moves: [...g.moves],
    captured: { w: [...g.captured.w], b: [...g.captured.b] },
    halfMoves: g.halfMoves,
    gameOver: g.gameOver
  };
}

function findKing(board, color) {
  const king = color === 'w' ? 'K' : 'k';
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++)
      if (board[r][c] === king) return [r, c];
  return null;
}

function isAttackedBy(board, r, c, byColor) {
  // Check if square (r,c) is attacked by any piece of byColor
  const pawnDir = byColor === 'w' ? 1 : -1;
  // Pawn attacks
  if (inBounds(r + pawnDir, c - 1) && board[r + pawnDir][c - 1] === (byColor === 'w' ? 'P' : 'p')) return true;
  if (inBounds(r + pawnDir, c + 1) && board[r + pawnDir][c + 1] === (byColor === 'w' ? 'P' : 'p')) return true;
  // Knight attacks
  const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
  const kn = byColor === 'w' ? 'N' : 'n';
  for (const [dr, dc] of knightMoves) {
    const nr = r + dr, nc = c + dc;
    if (inBounds(nr, nc) && board[nr][nc] === kn) return true;
  }
  // King attacks
  for (let dr = -1; dr <= 1; dr++)
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (inBounds(nr, nc) && board[nr][nc] === (byColor === 'w' ? 'K' : 'k')) return true;
    }
  // Sliding pieces (rook/queen for straights, bishop/queen for diags)
  const straight = [[0,1],[0,-1],[1,0],[-1,0]];
  const diag = [[1,1],[1,-1],[-1,1],[-1,-1]];
  const rq = byColor === 'w' ? ['R','Q'] : ['r','q'];
  const bq = byColor === 'w' ? ['B','Q'] : ['b','q'];
  for (const [dr, dc] of straight) {
    for (let i = 1; i < 8; i++) {
      const nr = r + dr * i, nc = c + dc * i;
      if (!inBounds(nr, nc)) break;
      if (board[nr][nc]) {
        if (rq.includes(board[nr][nc])) return true;
        break;
      }
    }
  }
  for (const [dr, dc] of diag) {
    for (let i = 1; i < 8; i++) {
      const nr = r + dr * i, nc = c + dc * i;
      if (!inBounds(nr, nc)) break;
      if (board[nr][nc]) {
        if (bq.includes(board[nr][nc])) return true;
        break;
      }
    }
  }
  return false;
}

function isInCheck(board, color) {
  const kp = findKing(board, color);
  if (!kp) return false;
  return isAttackedBy(board, kp[0], kp[1], color === 'w' ? 'b' : 'w');
}

function generatePseudoMoves(g, color) {
  const moves = [];
  const dir = color === 'w' ? -1 : 1;
  const startRow = color === 'w' ? 6 : 1;

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = g.board[r][c];
      if (!p || colorOf(p) !== color) continue;
      const t = typeOf(p);

      if (t === 'P') {
        // Forward
        if (inBounds(r + dir, c) && !g.board[r + dir][c]) {
          moves.push({ from: [r, c], to: [r + dir, c] });
          // Double push
          if (r === startRow && !g.board[r + 2 * dir][c]) {
            moves.push({ from: [r, c], to: [r + 2 * dir, c] });
          }
        }
        // Captures
        for (const dc of [-1, 1]) {
          const nr = r + dir, nc = c + dc;
          if (!inBounds(nr, nc)) continue;
          if (g.board[nr][nc] && colorOf(g.board[nr][nc]) !== color) {
            moves.push({ from: [r, c], to: [nr, nc] });
          }
          // En passant
          if (g.enPassant && g.enPassant[0] === nr && g.enPassant[1] === nc) {
            moves.push({ from: [r, c], to: [nr, nc], enPassant: true });
          }
        }
      } else if (t === 'N') {
        for (const [dr, dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
          const nr = r + dr, nc = c + dc;
          if (inBounds(nr, nc) && colorOf(g.board[nr][nc]) !== color) {
            moves.push({ from: [r, c], to: [nr, nc] });
          }
        }
      } else if (t === 'K') {
        for (let dr = -1; dr <= 1; dr++)
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = r + dr, nc = c + dc;
            if (inBounds(nr, nc) && colorOf(g.board[nr][nc]) !== color) {
              moves.push({ from: [r, c], to: [nr, nc] });
            }
          }
        // Castling
        const row = color === 'w' ? 7 : 0;
        if (r === row && c === 4) {
          const enemy = color === 'w' ? 'b' : 'w';
          // Kingside
          const ks = color === 'w' ? 'K' : 'k';
          if (g.castling[ks] && !g.board[row][5] && !g.board[row][6] &&
              g.board[row][7] === (color === 'w' ? 'R' : 'r') &&
              !isAttackedBy(g.board, row, 4, enemy) &&
              !isAttackedBy(g.board, row, 5, enemy) &&
              !isAttackedBy(g.board, row, 6, enemy)) {
            moves.push({ from: [r, c], to: [row, 6], castle: 'K' });
          }
          // Queenside
          const qs = color === 'w' ? 'Q' : 'q';
          if (g.castling[qs] && !g.board[row][3] && !g.board[row][2] && !g.board[row][1] &&
              g.board[row][0] === (color === 'w' ? 'R' : 'r') &&
              !isAttackedBy(g.board, row, 4, enemy) &&
              !isAttackedBy(g.board, row, 3, enemy) &&
              !isAttackedBy(g.board, row, 2, enemy)) {
            moves.push({ from: [r, c], to: [row, 2], castle: 'Q' });
          }
        }
      } else {
        // Sliding pieces
        let dirs = [];
        if (t === 'R' || t === 'Q') dirs.push([0,1],[0,-1],[1,0],[-1,0]);
        if (t === 'B' || t === 'Q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
        for (const [dr, dc] of dirs) {
          for (let i = 1; i < 8; i++) {
            const nr = r + dr * i, nc = c + dc * i;
            if (!inBounds(nr, nc)) break;
            if (g.board[nr][nc]) {
              if (colorOf(g.board[nr][nc]) !== color) moves.push({ from: [r, c], to: [nr, nc] });
              break;
            }
            moves.push({ from: [r, c], to: [nr, nc] });
          }
        }
      }
    }
  }
  return moves;
}

function generateLegalMoves(g, color) {
  const pseudo = generatePseudoMoves(g, color);
  const legal = [];
  for (const m of pseudo) {
    const newBoard = g.board.map(row => [...row]);
    // Execute on temp board
    newBoard[m.to[0]][m.to[1]] = newBoard[m.from[0]][m.from[1]];
    newBoard[m.from[0]][m.from[1]] = null;
    if (m.enPassant) {
      newBoard[m.from[0]][m.to[1]] = null;
    }
    if (m.castle) {
      const row = m.from[0];
      if (m.castle === 'K') { newBoard[row][5] = newBoard[row][7]; newBoard[row][7] = null; }
      else { newBoard[row][3] = newBoard[row][0]; newBoard[row][0] = null; }
    }
    if (!isInCheck(newBoard, color)) {
      // Check for promotion
      const piece = g.board[m.from[0]][m.from[1]];
      const promoRow = color === 'w' ? 0 : 7;
      if (typeOf(piece) === 'P' && m.to[0] === promoRow) {
        m.promotion = true;
      }
      legal.push(m);
    }
  }
  return legal;
}

function makeMove(g, move, promotionPiece) {
  const ng = cloneGame(g);
  const piece = ng.board[move.from[0]][move.from[1]];
  const captured = ng.board[move.to[0]][move.to[1]];
  const color = colorOf(piece);
  const t = typeOf(piece);

  // Track captures
  if (captured) {
    ng.captured[colorOf(captured)].push(captured);
    ng.halfMoves = 0;
  } else if (t === 'P') {
    ng.halfMoves = 0;
  } else {
    ng.halfMoves++;
  }

  // Move piece
  ng.board[move.to[0]][move.to[1]] = piece;
  ng.board[move.from[0]][move.from[1]] = null;

  // En passant capture
  if (move.enPassant) {
    const capPiece = ng.board[move.from[0]][move.to[1]];
    if (capPiece) ng.captured[colorOf(capPiece)].push(capPiece);
    ng.board[move.from[0]][move.to[1]] = null;
  }

  // Castling
  if (move.castle) {
    const row = move.from[0];
    if (move.castle === 'K') {
      ng.board[row][5] = ng.board[row][7];
      ng.board[row][7] = null;
    } else {
      ng.board[row][3] = ng.board[row][0];
      ng.board[row][0] = null;
    }
  }

  // Pawn promotion
  if (move.promotion) {
    const pp = promotionPiece || 'Q';
    ng.board[move.to[0]][move.to[1]] = color === 'w' ? pp.toUpperCase() : pp.toLowerCase();
  }

  // Update en passant
  ng.enPassant = null;
  if (t === 'P' && Math.abs(move.to[0] - move.from[0]) === 2) {
    ng.enPassant = [(move.from[0] + move.to[0]) / 2, move.from[1]];
  }

  // Update castling rights
  if (t === 'K') {
    if (color === 'w') { ng.castling.K = false; ng.castling.Q = false; }
    else { ng.castling.k = false; ng.castling.q = false; }
  }
  if (t === 'R') {
    if (move.from[0] === 7 && move.from[1] === 0) ng.castling.Q = false;
    if (move.from[0] === 7 && move.from[1] === 7) ng.castling.K = false;
    if (move.from[0] === 0 && move.from[1] === 0) ng.castling.q = false;
    if (move.from[0] === 0 && move.from[1] === 7) ng.castling.k = false;
  }
  // If rook captured
  if (move.to[0] === 0 && move.to[1] === 0) ng.castling.q = false;
  if (move.to[0] === 0 && move.to[1] === 7) ng.castling.k = false;
  if (move.to[0] === 7 && move.to[1] === 0) ng.castling.Q = false;
  if (move.to[0] === 7 && move.to[1] === 7) ng.castling.K = false;

  // Build algebraic notation
  ng.moves.push(buildNotation(g, move, ng, piece, captured, promotionPiece));

  // Switch turn
  ng.turn = ng.turn === 'w' ? 'b' : 'w';
  return ng;
}

function buildNotation(oldGame, move, newGame, piece, captured, promotionPiece) {
  const t = typeOf(piece);
  const files = 'abcdefgh';
  const toSq = files[move.to[1]] + (8 - move.to[0]);

  if (move.castle) return move.castle === 'K' ? 'O-O' : 'O-O-O';

  let n = '';
  if (t !== 'P') {
    n += t;
    // Disambiguate
    const color = colorOf(piece);
    const same = [];
    for (let r = 0; r < 8; r++)
      for (let c = 0; c < 8; c++)
        if (oldGame.board[r][c] === piece && !(r === move.from[0] && c === move.from[1])) {
          const moves = generateLegalMoves(oldGame, color);
          if (moves.some(m => m.from[0] === r && m.from[1] === c && m.to[0] === move.to[0] && m.to[1] === move.to[1]))
            same.push([r, c]);
        }
    if (same.length > 0) {
      if (same.every(s => s[1] !== move.from[1])) n += files[move.from[1]];
      else if (same.every(s => s[0] !== move.from[0])) n += (8 - move.from[0]);
      else n += files[move.from[1]] + (8 - move.from[0]);
    }
  }

  if (captured || move.enPassant) {
    if (t === 'P') n += files[move.from[1]];
    n += 'x';
  }
  n += toSq;

  if (move.promotion) n += '=' + (promotionPiece || 'Q');

  // Check/Checkmate â€” turn hasn't been switched yet in makeMove,
  // so the opponent is the opposite of newGame.turn
  const nextColor = newGame.turn === 'w' ? 'b' : 'w';
  if (isInCheck(newGame.board, nextColor)) {
    const nextMoves = generateLegalMoves(newGame, nextColor);
    n += nextMoves.length === 0 ? '#' : '+';
  }

  return n;
}

// ========== AI ==========

function evaluateBoard(g) {
  let score = 0;
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = g.board[r][c];
      if (!p) continue;
      const t = typeOf(p);
      const val = PIECE_VALUES[t] || 0;
      const idx = isWhite(p) ? r * 8 + c : (7 - r) * 8 + c;
      const pst = PST[t] ? PST[t][idx] : 0;
      if (isWhite(p)) score += val + pst;
      else score -= val + pst;
    }
  }
  return score;
}

function minimax(g, depth, alpha, beta, maximizing) {
  const color = maximizing ? 'w' : 'b';
  const moves = generateLegalMoves(g, g.turn);

  if (moves.length === 0) {
    if (isInCheck(g.board, g.turn)) return maximizing ? -99999 + (4 - depth) : 99999 - (4 - depth);
    return 0; // stalemate
  }
  if (depth === 0) return evaluateBoard(g);

  // Move ordering: captures first, then by piece value
  moves.sort((a, b) => {
    const capA = g.board[a.to[0]][a.to[1]] ? PIECE_VALUES[typeOf(g.board[a.to[0]][a.to[1]])] : 0;
    const capB = g.board[b.to[0]][b.to[1]] ? PIECE_VALUES[typeOf(g.board[b.to[0]][b.to[1]])] : 0;
    return capB - capA;
  });

  if (maximizing) {
    let maxEval = -Infinity;
    for (const m of moves) {
      const promoPiece = m.promotion ? 'Q' : null;
      const ng = makeMove(g, m, promoPiece);
      const ev = minimax(ng, depth - 1, alpha, beta, false);
      maxEval = Math.max(maxEval, ev);
      alpha = Math.max(alpha, ev);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const m of moves) {
      const promoPiece = m.promotion ? 'Q' : null;
      const ng = makeMove(g, m, promoPiece);
      const ev = minimax(ng, depth - 1, alpha, beta, true);
      minEval = Math.min(minEval, ev);
      beta = Math.min(beta, ev);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function aiBestMove(g) {
  const depth = parseInt(document.getElementById('difficultySelect').value);
  const moves = generateLegalMoves(g, g.turn);
  if (moves.length === 0) return null;

  let bestMove = moves[0];
  let bestScore = Infinity; // AI is black, minimizing
  const alpha = -Infinity;
  let beta = Infinity;

  // Move ordering
  moves.sort((a, b) => {
    const capA = g.board[a.to[0]][a.to[1]] ? PIECE_VALUES[typeOf(g.board[a.to[0]][a.to[1]])] : 0;
    const capB = g.board[b.to[0]][b.to[1]] ? PIECE_VALUES[typeOf(g.board[b.to[0]][b.to[1]])] : 0;
    return capB - capA;
  });

  for (const m of moves) {
    const promoPiece = m.promotion ? 'Q' : null;
    const ng = makeMove(g, m, promoPiece);
    const score = minimax(ng, depth - 1, -Infinity, beta, true);
    if (score < bestScore) {
      bestScore = score;
      bestMove = m;
      beta = Math.min(beta, score);
    }
  }
  return { move: bestMove, promoPiece: bestMove.promotion ? 'Q' : null };
}

function playerBestMove(g) {
  const depth = parseInt(document.getElementById('difficultySelect').value);
  const moves = generateLegalMoves(g, g.turn);
  if (moves.length === 0) return null;

  let bestMove = moves[0];
  let bestScore = -Infinity; // Player is white, maximizing
  let alpha = -Infinity;
  const beta = Infinity;

  moves.sort((a, b) => {
    const capA = g.board[a.to[0]][a.to[1]] ? PIECE_VALUES[typeOf(g.board[a.to[0]][a.to[1]])] : 0;
    const capB = g.board[b.to[0]][b.to[1]] ? PIECE_VALUES[typeOf(g.board[b.to[0]][b.to[1]])] : 0;
    return capB - capA;
  });

  for (const m of moves) {
    const promoPiece = m.promotion ? 'Q' : null;
    const ng = makeMove(g, m, promoPiece);
    const score = minimax(ng, depth - 1, alpha, Infinity, false);
    if (score > bestScore) {
      bestScore = score;
      bestMove = m;
      alpha = Math.max(alpha, score);
    }
  }
  return bestMove;
}

// ========== UI ==========

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const moveListEl = document.getElementById('moveList');
const capturedWhiteEl = document.getElementById('capturedWhite');
const capturedBlackEl = document.getElementById('capturedBlack');
const promotionOverlay = document.getElementById('promotionOverlay');
const promotionPiecesEl = document.getElementById('promotionPieces');
const modeSelect = document.getElementById('modeSelect');
const difficultySelect = document.getElementById('difficultySelect');
const newGameBtn = document.getElementById('newGameBtn');

let lastMove = null;
let hintShowing = false;
let hintOverlayEl = null;
const hintBtn = document.getElementById('hintBtn');

function render() {
  boardEl.innerHTML = '';
  const files = 'abcdefgh';

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const sq = document.createElement('div');
      sq.className = 'square ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
      sq.dataset.row = r;
      sq.dataset.col = c;

      // Coordinate labels
      if (r === 7) {
        const fl = document.createElement('span');
        fl.className = 'coord-label file-label';
        fl.textContent = files[c];
        sq.appendChild(fl);
      }
      if (c === 0) {
        const rl = document.createElement('span');
        rl.className = 'coord-label rank-label';
        rl.textContent = 8 - r;
        sq.appendChild(rl);
      }

      // Highlights
      if (lastMove) {
        if ((r === lastMove.from[0] && c === lastMove.from[1]) ||
            (r === lastMove.to[0] && c === lastMove.to[1])) {
          sq.classList.add('last-move');
        }
      }
      if (selectedSquare && selectedSquare[0] === r && selectedSquare[1] === c) {
        sq.classList.add('selected');
      }
      if (selectedSquare) {
        const legalMove = legalMovesCache.find(m => m.to[0] === r && m.to[1] === c);
        if (legalMove) {
          const isCapture = game.board[r][c] || legalMove.enPassant;
          sq.classList.add(isCapture ? 'legal-capture' : 'legal-move');
        }
      }

      // Check highlight
      const piece = game.board[r][c];
      if (piece && typeOf(piece) === 'K' && colorOf(piece) === game.turn && isInCheck(game.board, game.turn) && !game.gameOver) {
        sq.classList.add('check');
      }

      if (piece) {
        sq.insertAdjacentHTML('beforeend', pieceHTML(piece));
      }

      sq.addEventListener('click', () => onSquareClick(r, c));
      boardEl.appendChild(sq);
    }
  }

  // Captured pieces
  const sortCap = arr => [...arr].sort((a, b) => (PIECE_VALUES[typeOf(b)] || 0) - (PIECE_VALUES[typeOf(a)] || 0));
  capturedBlackEl.innerHTML = sortCap(game.captured.b).map(p => `<span style="display:inline-block;width:1.5rem;height:1.5rem;">${pieceHTML(p)}</span>`).join('');
  capturedWhiteEl.innerHTML = sortCap(game.captured.w).map(p => `<span style="display:inline-block;width:1.5rem;height:1.5rem;">${pieceHTML(p)}</span>`).join('');

  // Move list
  moveListEl.innerHTML = '';
  for (let i = 0; i < game.moves.length; i += 2) {
    const row = document.createElement('div');
    row.className = 'move-row';
    row.innerHTML = `<span class="move-num">${Math.floor(i / 2) + 1}.</span>` +
      `<span class="move-white">${game.moves[i]}</span>` +
      `<span class="move-black">${game.moves[i + 1] || ''}</span>`;
    moveListEl.appendChild(row);
  }
  moveListEl.scrollTop = moveListEl.scrollHeight;

  // Status
  updateStatus();
}

function updateStatus() {
  const inCheck = isInCheck(game.board, game.turn);
  const moves = generateLegalMoves(game, game.turn);
  const turnName = game.turn === 'w' ? 'White' : 'Black';

  if (moves.length === 0) {
    game.gameOver = true;
    if (inCheck) {
      const winner = game.turn === 'w' ? 'Black' : 'White';
      statusEl.textContent = `Checkmate! ${winner} wins!`;
      statusEl.className = 'status mate-status';
    } else {
      statusEl.textContent = 'Stalemate! Draw.';
      statusEl.className = 'status mate-status';
      if (isAIMode()) aiSay(pick(COMMENTS.stalemateDraw));
    }
  } else if (game.halfMoves >= 100) {
    game.gameOver = true;
    statusEl.textContent = 'Draw by 50-move rule.';
    statusEl.className = 'status mate-status';
    if (isAIMode()) aiSay("50 moves without a capture or pawn move. It's a draw!");
  } else if (inCheck) {
    statusEl.textContent = `${turnName} is in check!`;
    statusEl.className = 'status check-status';
  } else {
    statusEl.textContent = `${turnName} to move`;
    statusEl.className = 'status';
    if (aiThinking) statusEl.textContent = 'Computer is thinking...';
  }
}

function onSquareClick(r, c) {
  if (game.gameOver || aiThinking) return;
  if (isAIMode() && game.turn === 'b') return;

  const piece = game.board[r][c];

  if (selectedSquare) {
    // Try to make a move
    const move = legalMovesCache.find(m => m.to[0] === r && m.to[1] === c);
    if (move) {
      if (move.promotion) {
        showPromotionDialog(move);
        return;
      }
      executeMove(move);
      return;
    }
    // Select a different piece
    if (piece && colorOf(piece) === game.turn) {
      selectedSquare = [r, c];
      legalMovesCache = generateLegalMoves(game, game.turn).filter(m => m.from[0] === r && m.from[1] === c);
      render();
      return;
    }
    // Deselect
    selectedSquare = null;
    legalMovesCache = [];
    render();
    return;
  }

  // Select a piece
  if (piece && colorOf(piece) === game.turn) {
    selectedSquare = [r, c];
    legalMovesCache = generateLegalMoves(game, game.turn).filter(m => m.from[0] === r && m.from[1] === c);
    render();
  }
}

function executeMove(move, promoPiece) {
  clearHint();
  const prevGame = cloneGame(game);
  game = makeMove(game, move, promoPiece);
  lastMove = move;
  selectedSquare = null;
  legalMovesCache = [];
  render();

  if (isAIMode()) {
    // AI reacts to the player's move
    aiSay(getPlayerComment(game, move));

    if (!game.gameOver && game.turn === 'b') {
      aiThinking = true;
      updateStatus();
      aiTimer = setTimeout(() => {
        aiSay(pick(COMMENTS.thinking));
        setTimeout(doAIMove, 400);
      }, 600);
    }
  }
}

function getSquareEl(r, c) {
  return boardEl.querySelector(`.square[data-row="${r}"][data-col="${c}"]`);
}

function animateMove(move, piece, callback) {
  const fromSq = getSquareEl(move.from[0], move.from[1]);
  const toSq = getSquareEl(move.to[0], move.to[1]);
  if (!fromSq || !toSq) { callback(); return; }

  const boardSection = boardEl.parentElement;
  const boardRect = boardEl.getBoundingClientRect();
  const sectionRect = boardSection.getBoundingClientRect();
  const fromRect = fromSq.getBoundingClientRect();
  const toRect = toSq.getBoundingClientRect();
  const sqSize = fromRect.width;

  // Positions relative to board-section
  const fromX = fromRect.left - sectionRect.left;
  const fromY = fromRect.top - sectionRect.top;
  const toX = toRect.left - sectionRect.left;
  const toY = toRect.top - sectionRect.top;
  const dx = toX - fromX;
  const dy = toY - fromY;

  // Create overlay outside the board (avoids overflow:hidden clipping)
  const overlay = document.createElement('div');
  overlay.className = 'anim-overlay';
  boardSection.appendChild(overlay);

  // Draw arrow from center of source to center of destination
  const fromCX = fromX + sqSize / 2;
  const fromCY = fromY + sqSize / 2;
  const toCX = toX + sqSize / 2;
  const toCY = toY + sqSize / 2;
  const ow = sectionRect.width;
  const oh = sectionRect.height;

  const arrow = document.createElement('div');
  arrow.className = 'move-arrow';
  arrow.style.left = '0';
  arrow.style.top = '0';
  arrow.style.width = ow + 'px';
  arrow.style.height = oh + 'px';
  // Build arrow as a single path (shaft + triangular head) for uniform color
  const adx = toCX - fromCX;
  const ady = toCY - fromCY;
  const len = Math.sqrt(adx * adx + ady * ady);
  const ux = adx / len;
  const uy = ady / len;
  const headLen = sqSize * 0.35;
  const headW = sqSize * 0.25;
  const shaftW = sqSize * 0.12;
  // Point where shaft meets head base
  const bx = toCX - ux * headLen;
  const by = toCY - uy * headLen;
  // Perpendicular
  const px = -uy;
  const py = ux;
  // Shaft corners
  const s1x = fromCX + px * shaftW / 2;
  const s1y = fromCY + py * shaftW / 2;
  const s2x = fromCX - px * shaftW / 2;
  const s2y = fromCY - py * shaftW / 2;
  const s3x = bx - px * shaftW / 2;
  const s3y = by - py * shaftW / 2;
  const s4x = bx + px * shaftW / 2;
  const s4y = by + py * shaftW / 2;
  // Head corners
  const h1x = bx + px * headW / 2;
  const h1y = by + py * headW / 2;
  const h2x = bx - px * headW / 2;
  const h2y = by - py * headW / 2;
  arrow.innerHTML = `<svg width="${ow}" height="${oh}" viewBox="0 0 ${ow} ${oh}" xmlns="http://www.w3.org/2000/svg">
    <polygon points="${s1x},${s1y} ${s4x},${s4y} ${h1x},${h1y} ${toCX},${toCY} ${h2x},${h2y} ${s3x},${s3y} ${s2x},${s2y}"
      fill="rgba(200,200,200,0.45)"/>
  </svg>`;
  overlay.appendChild(arrow);

  // Hide the piece on the source square during animation
  const pieceSvg = fromSq.querySelector('.piece-svg');
  if (pieceSvg) pieceSvg.style.visibility = 'hidden';

  // Create floating animated piece
  const anim = document.createElement('div');
  anim.className = 'animating-piece';
  anim.style.width = sqSize + 'px';
  anim.style.height = sqSize + 'px';
  anim.style.display = 'flex';
  anim.style.alignItems = 'center';
  anim.style.justifyContent = 'center';
  anim.innerHTML = pieceHTML(piece);
  anim.style.left = fromX + 'px';
  anim.style.top = fromY + 'px';
  anim.style.transform = 'translate(0, 0)';
  anim.style.transition = 'none';
  overlay.appendChild(anim);

  // Force layout, then start animation
  anim.getBoundingClientRect();
  anim.style.transition = 'transform 1.575s cubic-bezier(0.25, 0.1, 0.25, 1)';

  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      anim.style.transform = `translate(${dx}px, ${dy}px)`;
    });
  });

  let done = false;
  function finish() {
    if (done) return;
    done = true;
    overlay.remove();
    callback();
  }

  anim.addEventListener('transitionend', finish, { once: true });

  // Fallback in case transitionend doesn't fire
  setTimeout(finish, 1800);
}

function doAIMove() {
  const result = aiBestMove(game);
  aiThinking = false;
  if (result) {
    const gBefore = cloneGame(game);
    const movingPiece = game.board[result.move.from[0]][result.move.from[1]];
    animateMove(result.move, movingPiece, () => {
      game = makeMove(game, result.move, result.promoPiece);
      lastMove = result.move;
      render();
      // AI comments on its own move
      aiSay(getAIComment(gBefore, game, result.move));
    });
  } else {
    render();
  }
}

function showPromotionDialog(move) {
  const color = game.turn;
  const pieces = color === 'w' ? ['Q','R','B','N'] : ['q','r','b','n'];
  promotionPiecesEl.innerHTML = '';
  for (const pp of pieces) {
    const btn = document.createElement('div');
    btn.className = 'promotion-piece';
    btn.innerHTML = pieceHTML(pp);
    btn.addEventListener('click', () => {
      promotionOverlay.style.display = 'none';
      executeMove(move, typeOf(pp));
    });
    promotionPiecesEl.appendChild(btn);
  }
  promotionOverlay.style.display = 'flex';
}

function isAIMode() { return modeSelect.value === 'ai'; }

// ========== HINT ==========

function clearHint() {
  if (hintOverlayEl) { hintOverlayEl.remove(); hintOverlayEl = null; }
  hintShowing = false;
  hintBtn.textContent = 'Hint';
}

function showHint() {
  if (game.gameOver || aiThinking || game.turn !== 'w') return;

  const bestMove = playerBestMove(game);
  if (!bestMove) return;

  const boardSection = boardEl.parentElement;
  const sectionRect = boardSection.getBoundingClientRect();
  const fromSq = getSquareEl(bestMove.from[0], bestMove.from[1]);
  const toSq = getSquareEl(bestMove.to[0], bestMove.to[1]);
  if (!fromSq || !toSq) return;

  const fromRect = fromSq.getBoundingClientRect();
  const toRect = toSq.getBoundingClientRect();
  const sqSize = fromRect.width;

  const fromCX = fromRect.left - sectionRect.left + sqSize / 2;
  const fromCY = fromRect.top - sectionRect.top + sqSize / 2;
  const toCX = toRect.left - sectionRect.left + sqSize / 2;
  const toCY = toRect.top - sectionRect.top + sqSize / 2;
  const ow = sectionRect.width;
  const oh = sectionRect.height;

  // Build dotted arrow
  const adx = toCX - fromCX;
  const ady = toCY - fromCY;
  const len = Math.sqrt(adx * adx + ady * ady);
  const ux = adx / len;
  const uy = ady / len;
  const headLen = sqSize * 0.35;
  const headW = sqSize * 0.31;
  const px = -uy;
  const py = ux;
  // Shorten the line so it ends at the head base
  const lineEndX = toCX - ux * headLen;
  const lineEndY = toCY - uy * headLen;
  // Arrowhead points
  const h1x = lineEndX + px * headW / 2;
  const h1y = lineEndY + py * headW / 2;
  const h2x = lineEndX - px * headW / 2;
  const h2y = lineEndY - py * headW / 2;

  const overlay = document.createElement('div');
  overlay.className = 'hint-overlay';
  overlay.innerHTML = `<svg width="${ow}" height="${oh}" viewBox="0 0 ${ow} ${oh}" xmlns="http://www.w3.org/2000/svg">
    <line x1="${fromCX}" y1="${fromCY}" x2="${lineEndX}" y2="${lineEndY}"
      stroke="rgba(180,180,180,0.6)" stroke-width="${sqSize * 0.099}"
      stroke-dasharray="${sqSize * 0.08} ${sqSize * 0.12}"
      stroke-linecap="butt"/>
    <polygon points="${h1x},${h1y} ${toCX},${toCY} ${h2x},${h2y}"
      fill="rgba(180,180,180,0.6)"/>
  </svg>`;
  boardSection.appendChild(overlay);
  hintOverlayEl = overlay;
  hintShowing = true;
  hintBtn.textContent = 'Hide Hint';
}

function toggleHint() {
  if (hintShowing) {
    clearHint();
  } else {
    showHint();
  }
}

hintBtn.addEventListener('click', toggleHint);

modeSelect.addEventListener('change', () => {
  difficultySelect.style.display = isAIMode() ? '' : 'none';
  speechWrapper.style.display = isAIMode() ? '' : 'none';
  hintBtn.style.display = isAIMode() ? '' : 'none';
  startNewGame();
});

newGameBtn.addEventListener('click', startNewGame);

function startNewGame() {
  if (aiTimer) { clearTimeout(aiTimer); aiTimer = null; }
  clearHint();
  initGame();
  lastMove = null;
  selectedSquare = null;
  legalMovesCache = [];
  aiThinking = false;
  render();
  if (isAIMode()) {
    aiSay(pick(COMMENTS.opening));
  } else {
    aiTextEl.textContent = '';
    speechWrapper.classList.add('empty');
  }
}

// ========== AI COMMENTARY ==========

const speechWrapper = document.getElementById('speechWrapper');
const aiTextEl = document.getElementById('aiText');

function aiSay(text) {
  aiTextEl.textContent = text;
  speechWrapper.classList.remove('empty');
}

function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

// Context analysis helpers
function countMaterial(board, color) {
  let total = 0;
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (p && colorOf(p) === color) total += PIECE_VALUES[typeOf(p)] || 0;
    }
  return total;
}

function getMoveContext(g, move, notation) {
  const ctx = {};
  ctx.notation = notation;
  ctx.piece = typeOf(g.board[move.from[0]][move.from[1]]);
  ctx.isCapture = notation.includes('x');
  ctx.isCheck = notation.includes('+');
  ctx.isMate = notation.includes('#');
  ctx.isCastle = notation.startsWith('O-');
  ctx.isPromotion = notation.includes('=');
  ctx.capturedPiece = null;
  if (ctx.isCapture) {
    // figure out what was captured from the board before the move
    const target = g.board[move.to[0]][move.to[1]];
    if (target) ctx.capturedPiece = typeOf(target);
    else if (move.enPassant) ctx.capturedPiece = 'P';
  }
  ctx.moveNum = Math.ceil(g.moves.length / 2) + 1;
  ctx.whiteMat = countMaterial(g.board, 'w');
  ctx.blackMat = countMaterial(g.board, 'b');
  ctx.matDiff = ctx.whiteMat - ctx.blackMat; // positive = white ahead
  return ctx;
}

// --- Comment banks ---

const COMMENTS = {
  // After the player moves
  playerGeneric: [
    "Interesting choice...",
    "Hmm, let me think about this.",
    "I see what you're doing.",
    "Okay, okay... not bad.",
    "Let me consider my options.",
    "You've given me something to think about.",
    "An ambitious move.",
    "Classic approach. Let's see where this goes.",
    "Alright, my turn to think.",
  ],
  playerGoodCapture: [
    "Ouch! That's going to cost me.",
    "Well played â€” I didn't want to lose that piece.",
    "You're sharpening the position. I respect that.",
    "A strong capture. I need to be careful now.",
    "That hurt. Let me regroup.",
    "Taking my pieces, are we? Two can play that game.",
  ],
  playerPawnCapture: [
    "Trading pawns, eh? The position opens up.",
    "Fair exchange in the pawn battle.",
    "Clearing the center, I see.",
  ],
  playerCheck: [
    "Check! My king needs to move.",
    "You're putting pressure on my king!",
    "Check â€” but don't get too excited yet.",
    "Bold! Let me get my king to safety.",
    "A check! You're keeping me on my toes.",
  ],
  playerCastle: [
    "Castling for safety â€” wise decision.",
    "Good idea to tuck your king away.",
    "Your king is safe now. But for how long?",
    "A solid castling move. Now the real fight begins.",
  ],
  playerQueenMove: [
    "Bringing out the big guns, I see.",
    "The queen enters the battle!",
    "Careful with your queen â€” she's valuable.",
    "An aggressive queen move. I like your style.",
  ],
  playerKnightMove: [
    "Tricky knight maneuver.",
    "Knights can be sneaky. I'll watch out.",
    "A knight hop â€” those are hard to predict.",
  ],
  playerEarlyGame: [
    "A solid opening move.",
    "Setting up your pieces â€” smart.",
    "Building your position. I'll do the same.",
    "Good development. Let's see your plan.",
    "Controlling the center â€” textbook play.",
  ],
  playerWhenBehind: [
    "You're fighting back â€” I respect that!",
    "Don't give up, there's still game to play.",
    "A scrappy move. Never count yourself out!",
    "Still plenty of fight left in your position.",
  ],
  playerWhenAhead: [
    "Hmm, you seem to have the advantage...",
    "I need to find a way back into this game.",
    "You're putting the pressure on. Well done.",
    "I'm going to have to play carefully here.",
  ],
  playerPromotion: [
    "A new queen! That's a game-changer.",
    "Promotion! Your pawn made it all the way.",
    "And the pawn becomes a queen â€” dangerous!",
  ],

  // After the AI moves
  aiGeneric: [
    "Your turn. Choose wisely.",
    "Let's see how you handle this.",
    "I think that's a solid move.",
    "There. Your move now.",
    "I've made my decision. What will you do?",
    "That should keep things interesting.",
    "A quiet move, but it has a purpose.",
    "The position is evolving nicely.",
  ],
  aiCapture: [
    "I'll take that, thank you!",
    "Nom nom nom. One fewer piece for you.",
    "That piece was looking lonely. I helped it off the board.",
    "A fair trade, wouldn't you say?",
    "Your piece was in the wrong place at the wrong time.",
    "I saw an opportunity and I took it.",
  ],
  aiBigCapture: [
    "Ha! That's a big catch!",
    "I think you'll miss that piece.",
    "A major piece down â€” this changes everything!",
    "That was an expensive mistake for you.",
    "I'll gladly accept that gift!",
  ],
  aiCheck: [
    "Check! Watch your king.",
    "Your king is in danger!",
    "Check! How will you escape?",
    "I'm coming for your king.",
    "Check! The pressure is on.",
  ],
  aiMate: [
    "Checkmate! Great game!",
    "And that's checkmate. Well played though!",
    "Checkmate! Maybe try a different approach next time?",
    "Game over! That was a tough battle.",
    "Checkmate! Want to go again?",
  ],
  aiCastle: [
    "Time to get my king to safety.",
    "Castling â€” my king appreciates the protection.",
    "Safe and sound behind my pawns.",
    "A good time to castle, I think.",
  ],
  aiPawnPush: [
    "Pushing forward, one step at a time.",
    "My pawns are on the march!",
    "A small move with big ambitions.",
    "Advancing the foot soldiers.",
  ],
  aiKnightMove: [
    "My knight finds a nice square.",
    "A little knight dance for you.",
    "The knight leaps into action!",
    "Knights love these kinds of positions.",
  ],
  aiWhenAhead: [
    "I'm feeling pretty good about my position.",
    "The advantage is mine. Can you turn it around?",
    "Things are looking my way!",
    "I'll try to convert this advantage.",
    "Slowly but surely, I'm squeezing you.",
  ],
  aiWhenBehind: [
    "I'm in trouble, but I won't go down without a fight!",
    "I need to be creative here to survive.",
    "Not my best position, but chess isn't over until it's over.",
    "Time to dig deep and find a way out.",
  ],
  aiDevelopment: [
    "Getting my pieces into the game.",
    "Development first, attack later.",
    "Preparing for the middlegame.",
    "Building my position piece by piece.",
  ],
  aiPromotion: [
    "A new queen for me! How do you like that?",
    "Promotion! My pawn fulfilled its destiny.",
    "Another queen on the board. Things just got serious.",
  ],

  // Game state comments
  stalemateDraw: [
    "A draw! Well fought.",
    "Stalemate â€” nobody wins today.",
    "A hard-fought draw. Shall we play again?",
  ],
  opening: [
    "Let's play! Make your move.",
    "Ready for a challenge? You go first.",
    "A new game! Show me what you've got.",
    "Fresh board, fresh chances. Your move!",
  ],
  thinking: [
    "Hmm, let me think...",
    "Give me a moment...",
    "Calculating possibilities...",
    "Let me consider this carefully...",
    "Thinking deep thoughts...",
  ]
};

function getPlayerComment(g, move) {
  const notation = g.moves[g.moves.length - 1] || '';
  const ctx = getMoveContext(game, move, notation); // note: game is already updated

  // Use pre-move game state for material (we need the state before the move)
  // Since game is already updated, approximate from context
  const moveNum = Math.ceil(g.moves.length / 2);

  if (ctx.isMate) return pick(["Checkmate?! No... wait... that can't be right!", "You got me! Well played!", "Checkmate! I bow to the superior player.", "Incredible finish! You earned that win."]);

  if (ctx.isPromotion) return pick(COMMENTS.playerPromotion);
  if (ctx.isCheck) return pick(COMMENTS.playerCheck);
  if (ctx.isCastle) return pick(COMMENTS.playerCastle);

  if (ctx.isCapture) {
    if (ctx.capturedPiece === 'Q') return pick(["My queen! That's a devastating blow.", "Losing my queen hurts. A lot.", "Well, there goes my best piece..."]);
    if (ctx.capturedPiece === 'R') return pick(["My rook! That's going to be hard to recover from.", "A rook down â€” you're pressing your advantage."]);
    if (ctx.capturedPiece === 'B' || ctx.capturedPiece === 'N') return pick(COMMENTS.playerGoodCapture);
    if (ctx.capturedPiece === 'P') return pick(COMMENTS.playerPawnCapture);
    return pick(COMMENTS.playerGoodCapture);
  }

  // Material-based comments
  const wMat = countMaterial(g.board, 'w');
  const bMat = countMaterial(g.board, 'b');
  const diff = wMat - bMat;
  if (diff > 300) return pick(COMMENTS.playerWhenAhead);
  if (diff < -300) return pick(COMMENTS.playerWhenBehind);

  // Early game
  if (moveNum <= 5) return pick(COMMENTS.playerEarlyGame);

  // Piece-specific
  if (ctx.piece === 'Q') return pick(COMMENTS.playerQueenMove);
  if (ctx.piece === 'N') return pick(COMMENTS.playerKnightMove);

  return pick(COMMENTS.playerGeneric);
}

function getAIComment(gBefore, gAfter, move) {
  const notation = gAfter.moves[gAfter.moves.length - 1] || '';
  const ctx = getMoveContext(gBefore, move, notation);
  const moveNum = Math.ceil(gAfter.moves.length / 2);

  if (ctx.isMate) return pick(COMMENTS.aiMate);
  if (ctx.isPromotion) return pick(COMMENTS.aiPromotion);

  if (ctx.isCheck) return pick(COMMENTS.aiCheck);
  if (ctx.isCastle) return pick(COMMENTS.aiCastle);

  if (ctx.isCapture) {
    if (ctx.capturedPiece === 'Q') return pick(["Your queen is mine! That changes everything!", "I'll take your queen, thank you very much!", "The queen falls! This is a turning point."]);
    if (ctx.capturedPiece === 'R') return pick(["I'll take that rook!", "One rook down for you.", ...COMMENTS.aiBigCapture.slice(0, 2)]);
    if (ctx.capturedPiece === 'B' || ctx.capturedPiece === 'N') return pick(COMMENTS.aiCapture);
    if (ctx.capturedPiece === 'P') return pick(COMMENTS.aiPawnPush);
    return pick(COMMENTS.aiCapture);
  }

  // Material-based
  const wMat = countMaterial(gAfter.board, 'w');
  const bMat = countMaterial(gAfter.board, 'b');
  const diff = wMat - bMat;
  if (diff < -300) return pick(COMMENTS.aiWhenAhead);
  if (diff > 300) return pick(COMMENTS.aiWhenBehind);

  // Early development
  if (moveNum <= 5) return pick(COMMENTS.aiDevelopment);

  // Piece-specific
  if (ctx.piece === 'N') return pick(COMMENTS.aiKnightMove);
  if (ctx.piece === 'P') return pick(COMMENTS.aiPawnPush);

  return pick(COMMENTS.aiGeneric);
}

// Init
initGame();
render();
if (isAIMode()) aiSay(pick(COMMENTS.opening));

// Expose state for testing
window._chess = {
  get game() { return game; },
  set game(g) { game = g; },
  get aiThinking() { return aiThinking; },
  set aiThinking(v) { aiThinking = v; },
  get selectedSquare() { return selectedSquare; },
  get lastMove() { return lastMove; },
  set lastMove(v) { lastMove = v; },
  render,
  startNewGame,
  initGame,
  generateLegalMoves,
  makeMove,
  isInCheck,
  findKing
};
</script>
</body>
</html>
